[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ISG 5312 - Genomic Data Analysis in Practice II",
    "section": "",
    "text": "Preface\nThis course is the second in a two part series on practical analysis of genomic data. The first course heavily emphasized Linux and HPC skills, the statistical computing language R, and the basics of high throughput sequencing data. It used a model workflow, bulk RNA-seq analysis, as a framework for developing basic competencies.\nThis course will broaden the focus to include higher level bioinformatics skills, such as using Git for version controlling code, an introduction to workflow languages through Nextflow, and introduces several more workflows (variant detection, genome assembly, and single-cell RNA-seq). The course comprises five modules, one for each of these topics.\nIn this semester students will also do independent projects where they pick a workflow and reanalyze a relevant public dataset.\nThere are five modules:\n\nIntroduction to version control with Git/GitHub.\nVariant Detection.\nGenome Assembly.\nscRNAseq\nPipeline development with Nextflow",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "01_1_git-ingStarted.html",
    "href": "01_1_git-ingStarted.html",
    "title": "1¬† First steps with Git",
    "section": "",
    "text": "2 Learning Objectives\nIn the first chapter of this module, you will learn the very basics of Git and learn how to set up a remote repository on GitHub.\nThere are GUI tools for using Git, but we‚Äôre going to focus on the command-line here (except when we get to GitHub).\nNote that explanation will be sparse here, as you will be expected to do some assigned reading and watch some videos.",
    "crumbs": [
      "Introduction to Git",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>First steps with Git</span>"
    ]
  },
  {
    "objectID": "01_1_git-ingStarted.html#installing-git",
    "href": "01_1_git-ingStarted.html#installing-git",
    "title": "1¬† First steps with Git",
    "section": "2.1 Installing Git",
    "text": "2.1 Installing Git\nYou‚Äôre going to want git to be installed on your local machine. There are instructions here\nIf you‚Äôre using a Mac, you‚Äôve probably already got it. If not, you can install Xcode developer tools, which will include it.\nIf you‚Äôre using Windows (and thus probably also WSL2) you may want it installed for both systems. See the Linux and Windows instructions here.\nNote that on Xanadu, the base installation of Git is waaay out of date. In most cases things will still work fine. Do git --version to see what version is currently running (üíÄ). You can module load git/2.30.0, however, if you run into problems.",
    "crumbs": [
      "Introduction to Git",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>First steps with Git</span>"
    ]
  },
  {
    "objectID": "01_1_git-ingStarted.html#a-brief-pause",
    "href": "01_1_git-ingStarted.html#a-brief-pause",
    "title": "1¬† First steps with Git",
    "section": "2.2 A brief pause‚Ä¶",
    "text": "2.2 A brief pause‚Ä¶\nBefore going further here, please do the readings and watch the videos in HuskyCT.",
    "crumbs": [
      "Introduction to Git",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>First steps with Git</span>"
    ]
  },
  {
    "objectID": "01_1_git-ingStarted.html#configuring-git",
    "href": "01_1_git-ingStarted.html#configuring-git",
    "title": "1¬† First steps with Git",
    "section": "2.3 Configuring Git",
    "text": "2.3 Configuring Git\nBefore we do much with Git, we want to make sure that your instances are configured correctly. Anywhere you‚Äôve got it installed, you want to set it up to say who you are. Run these commands everywhere you might use it (Mac, Windows, WSL, and don‚Äôt forget Xanadu!), but obviously, please edit them first.\ngit config --global user.name \"Bob Loblaw\"\ngit config --global user.mail \"Bob.Loblaw@BobLoblawsLawBlog.com\"\nThe config subcommand edits git‚Äôs configuration file. --global applies settings to all the current user‚Äôs repositories on this computer (you can change these settings for individual repositories). You can see your configuration with\ngit config -l\n\n2.3.1 Git‚Äôs text editor\nGit is meant to hide in the background. You don‚Äôt use it to write or edit code, but to track it as it develops. Nevertheless, there are a times when Git will demand that you explain something, or reconcile conflicting edits. When that happens it will drop you into a text editor.\n\n2.3.1.1 vim\nBy default that text editor is vi, a powerful and widely used command line editor that comes with, shall we say, a steep learning curve.\nYou can change this. First let‚Äôs quickly cover the absolute barest of details for vi (more likely an updated version vim), as you will sooner or later run into it.\nLet‚Äôs create a dummy file with some text.\necho {a..z} | sed 's/ /\\n/g' &gt;letters.txt\nWe can open it with vi\nvi letters.txt\nAfter opening, you are in Normal mode. You can navigate around, but not edit.\nIf you press i you will go into Insert mode. Now you can edit. Press escape to go back to normal mode. Beware there are several other modes.\nQuitting vi is famously annoying to people who don‚Äôt know how to use it (or who have learned and forgotten many times).\nFirst, go to normal mode by pressing escape. After this:\n\nIf you have made no edits and wish to quit, you can type : then q then enter (:q then enter).\nIf you have made edits you wish to discard, you can type :q! then enter.\nIf you have made edits you wish to save you can type :w then enter THEN :q OR just :wq then enter.\n\n\nIf you want the bragging rights (and efficiency) that come with being proficient at using a powerful command-line editor, there are lots of ways to learn. One is through this game, vim adventures.\n\n\n2.3.1.2 Changing the text editor (if you want)\nIf you thought, ‚Äúvim is fine‚Äù, then fantastic, you can keep using it. If you thought, ‚Äúyuck‚Äù, and want to change the editor, you can use git config.\nIf you wanted to use nano for instance, you could do:\ngit config --global core.editor nano\nYou can also use VS Code (only on your local machine). First, you have to enable launching VS Code from the command line (see here)\nThen run\ngit config --global core.editor \"code --wait\"\nThe flag --wait will cause the terminal to wait until VS Code is closed before moving on.",
    "crumbs": [
      "Introduction to Git",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>First steps with Git</span>"
    ]
  },
  {
    "objectID": "01_1_git-ingStarted.html#git-basics",
    "href": "01_1_git-ingStarted.html#git-basics",
    "title": "1¬† First steps with Git",
    "section": "2.4 Git Basics",
    "text": "2.4 Git Basics\nOk, hopefully git is all set up now. We can run through the basics. There are two ways you might get started with a Git repository.\n\nYou create a new one in a brand new directory as you would with a new project.\nYou can clone a copy of an existing repository to alter or contribute to it. Perhaps one from GitHub (or GitLab, or BitBucket).\n\n\n2.4.1 Starting a new repository:\nTo start a git repository:\nmkdir newproject\ncd newproject\ngit init\nWhich writes out:\nhint: Using 'master' as the name for the initial branch. This default branch name\nhint: is subject to change. To configure the initial branch name to use in all\nhint: of your new repositories, which will suppress this warning, call:\nhint: \nhint:   git config --global init.defaultBranch &lt;name&gt;\nhint: \nhint: Names commonly chosen instead of 'master' are 'main', 'trunk' and\nhint: 'development'. The just-created branch can be renamed via this command:\nhint: \nhint:   git branch -m &lt;name&gt;\nInitialized empty Git repository in /home/FCAM/blah/blah/blah/newproject/.git/\nYou can see (with ls -a) that a hidden directory newproject/.git/ has been created. This .git directory is where Git will store the whole version control history. You should never muck around in .git. If for some reason you wanted to destroy the whole version history, you could delete .git and do git init to start anew.\n\n\n2.4.2 Cloning a repository\nWe saw this last semester with our RNAseq example, but you can clone a git repository like this:\ngit clone https://github.com/isg-certificate/rnaseq.git\ncd rnaseq\nWith stderr output:\nCloning into 'rnaseq'...\nremote: Enumerating objects: 85, done.\nremote: Counting objects: 100% (85/85), done.\nremote: Compressing objects: 100% (62/62), done.\nremote: Total 85 (delta 35), reused 66 (delta 19), pack-reused 0 (from 0)\nReceiving objects: 100% (85/85), 20.91 KiB | 509.00 KiB/s, done.\nResolving deltas: 100% (35/35), done.\nIf we do ls -la:\ndrwxr-xr-x 5 nreid cbc 2560 Jan  6 17:05 .\ndrwxr-xr-x 4 nreid cbc 1024 Jan  6 17:05 ..\ndrwxr-xr-x 8 nreid cbc 5632 Jan  6 17:05 .git\n-rw-r--r-- 1 nreid cbc   68 Jan  6 17:05 .gitignore\ndrwxr-xr-x 2 nreid cbc  512 Jan  6 17:05 metadata\n-rw-r--r-- 1 nreid cbc    8 Jan  6 17:05 README.md\ndrwxr-xr-x 7 nreid cbc 2560 Jan  6 17:05 scripts\nYou can see we grab all the contents of the repository, but also we have a .git directory.\n\n\n2.4.3 Adding files to the repository\nAdding a file (or a change to a file) to the repository happens in three steps.\n\nYou create (or alter) a file.\nYou add the file to the staging area.\nYou commit the file.\n\nLet‚Äôs consider our fresh, clean repository newproject. Let‚Äôs assume we‚Äôre going to start a new bioinformatics project. cd into newproject and type git status. You should see this:\n# On branch master\n#\n# Initial commit\n#\nnothing to commit (create/copy files and use \"git add\" to track)\ngit status gives us a summary of any changes that have been made to the repository since it was last ‚Äúcommitted‚Äù (more in a moment).\nLet‚Äôs create a script:\n# this syntax allows you to print a multi-line file and redirect it. \ncat &lt;&lt;EOF &gt;hw.sh\n#!/bin/bash\n\necho \"Hello World!\"\nEOF\n\nbash hw.sh\nNow git status again:\n# On branch master\n#\n# Initial commit\n#\n# Untracked files:\n#   (use \"git add &lt;file&gt;...\" to include in what will be committed)\n#\n#   hw.sh\nnothing added to commit but untracked files present (use \"git add\" to track)\nGit sees that we have a new file that is not being tracked as part of the repository. We can have lots of files that are not tracked as part of the repository. In fact, when doing bioinformatics, we probably want to keep all our results (and maybe even the data) in this working directory, but we do not want to keep them as part of the\nWe can add this file to the staging area with git add hw.sh. We could also add everything in the repository with git add --all.\n# On branch master\n#\n# Initial commit\n#\n# Changes to be committed:\n#   (use \"git rm --cached &lt;file&gt;...\" to unstage)\n#\n#   new file:   hw.sh\n#\nNow git is tracking the file and its current contents have been staged, but it has NOT been committed to the repository. Remember, there are three conceptual spaces in Git, the working directory (where we actually work) the staging area (where we add changes temporarily) and the repository (where we more or less permanently record updates to the project).\nNow that we‚Äôve got our file in the staging area, we can commit it to the repository.\ngit commit -m \"first commit\"\nThat produces the message:\n[master (root-commit) fe2dafd] first commit added hw.sh\n 1 file changed, 3 insertions(+)\n create mode 100644 hw.sh \nNow we‚Äôve committed the first file to the repository.\nThere is lots more to learn, including branching, merging, inspecting the history‚Ä¶ we‚Äôll get to that in the next chapter. For the last part of this chapter we‚Äôll introduce GitHub,",
    "crumbs": [
      "Introduction to Git",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>First steps with Git</span>"
    ]
  },
  {
    "objectID": "01_1_git-ingStarted.html#remote-repositories",
    "href": "01_1_git-ingStarted.html#remote-repositories",
    "title": "1¬† First steps with Git",
    "section": "2.5 Remote repositories",
    "text": "2.5 Remote repositories\nGit is a distributed version control system, so it naturally allows us (and collaborators) to maintain and interact with remote copies of our repositories.\nAssuming you cloned rnaseq above, if you enter the working directory and type\ngit remote -v\nYou will see:\norigin  https://github.com/isg-certificate/rnaseq.git (fetch)\norigin  https://github.com/isg-certificate/rnaseq.git (push)\nThis indicates the cloned repository is using a repository at the URL https://github.com/isg-certificate/rnaseq.git as a remote. rnaseq.git is a Git repository in the same sense that the .git directory in newproject is a Git repository. The remote is named origin. This is arbitrary and the default choice in git. You can name remotes anything you want. (fetch) and (push) mean that pulling down changes from the remote and pushing them up uses the same URL. The repository is hosted at GitHub (more in the next section), which controls access, so you won‚Äôt have permission to push any changes you might make.\nIf you cd to our brand new directory newproject and do git remote -v You should see no output.\n\n2.5.1 Adding a remote repository\nMost people host remote repositories, well, remotely, but to make things clear (hopefully) we‚Äôll create a remote repository for newproject locally.\ncd into the directory containing newproject (not newproject itself) and do\ngit init --bare remotenewproject.git\nIf you do ls you should now see (at least) newproject  remotenewproject.git.\nremotenewproject.git is a git repository, like .git in newproject. There is no working directory (or working tree, as git sometimes calls it). You cannot directly edit the files in this remote (without changing some settings first). This is a result of the option --bare. You want this because you want the remote to serve as a common access point or a backup of your code.\nNow cd back into newproject. You can add remotenewproject.git like this:\ngit remote add origin ../remotenewproject.git\nThe git remote add is adding a remote (arbitrarily) named origin at the location ../remotenewproject.git.\nIf you do git remote -v you‚Äôll see\norigin  ../remotenewproject.git (fetch)\norigin  ../remotenewproject.git (push)\nThe remote repository currently does not have any of our local commits in it. We will cover branches in the next chapter, but to push our local commits to the remote, we need to set an ‚Äúupstream‚Äù branch in the remote repository to push to.\nWe can see that our current branch does not have an upstream remote branch to push to by doing:\ngit branch -vv\n* master bf15b43 initial commit\nWe can set the upstream branch and push in one command:\ngit push -u origin master\nCounting objects: 3, done.\nWriting objects: 100% (3/3), 226 bytes | 0 bytes/s, done.\nTotal 3 (delta 0), reused 0 (delta 0)\nTo ../remotenewproject.git\n * [new branch]      master -&gt; master\nBranch master set up to track remote branch master from origin.\n-u origin says we‚Äôre setting up an upstream branch in origin master is the (arbitrary) name of the local and remote branch we‚Äôre pushing.\nDo git branch -vv to see we have now set up a remote master branch at origin:\n* master bf15b43 [origin/master] initial commit\nIn the future we can just do git push to push changes to the remote.\n\n\n2.5.2 Pushing and pulling from remotes.\nThere are many cases, such as collaboration, or a single person using multiple workstations, where you will have a single central remote repository and clones in multiple locations. You may update the code in one place, push it to the remote, and then need to pull it down in another place. This can get complicated (more in the next chapter) but we‚Äôll do a simple version of that now.\nFirst, clone a new copy of the remote:\ngit clone remotenewproject.git newproject_copy\nCloning into 'newproject_copy'...\ndone.\nNow ls and see: newproject  newproject_copy  remotenewproject.git.\nWe have the original directory we created, the remote repository, and our new clone. cd into newproject_copy and create a new file:\ncat &lt;&lt;EOF &gt;hm.sh\n#!/bin/bash\n\necho \"Hola Mundo!\"\nEOF\n\nbash hm.sh\nNow: git status\n# On branch master\n# Untracked files:\n#   (use \"git add &lt;file&gt;...\" to include in what will be committed)\n#\n#   hm.sh\nnothing added to commit but untracked files present (use \"git add\" to track)\nDo git add hm.sh and then git commit -m \"added hola mundo script\"\nNow git status:\n# On branch master\n# Your branch is ahead of 'origin/master' by 1 commit.\n#   (use \"git push\" to publish your local commits)\n#\nnothing to commit, working directory clean\nOur branch is 1 commit ahead of the remote.\nNow git push to send the local repository changes to the remote:\nCounting objects: 4, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (2/2), done.\nWriting objects: 100% (3/3), 312 bytes | 0 bytes/s, done.\nTotal 3 (delta 0), reused 0 (delta 0)\nTo /path/to/remotenewproject.git\n   bf15b43..7f84097  master -&gt; master\nNow go back to our original newproject directory and git status. You‚Äôll see it does not know that the remote repository has been updated. To pull down any changes do git pull\nremote: Counting objects: 4, done.\nremote: Compressing objects: 100% (2/2), done.\nremote: Total 3 (delta 0), reused 0 (delta 0)\nUnpacking objects: 100% (3/3), done.\nFrom ../remotenewproject\n   bf15b43..7f84097  master     -&gt; origin/master\nUpdating bf15b43..7f84097\nFast-forward\n hm.sh | 3 +++\n 1 file changed, 3 insertions(+)\n create mode 100644 hm.sh\nls should show we now have our new file.\nTo see our commit history try git log\ncommit 7f84097d7c3528e43023c66b5ddfc7d302567002\nAuthor: Noah Reid &lt;noah@uconn.edu&gt;\nDate:   Wed Dec 31 23:59:59 1999 -0500\n\n    added hola mundo script\n\ncommit bf15b4396cb1c7379c03bbca9222ef46f2384359\nAuthor: Noah Reid &lt;noah@uconn.edu&gt;\nDate:   Wed Dec 31 11:59:59 1999 -0500\n\n    initial commit\nThis process can get complicated, and conflicts can arise. We‚Äôll deal with that in the next chapter.",
    "crumbs": [
      "Introduction to Git",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>First steps with Git</span>"
    ]
  },
  {
    "objectID": "01_1_git-ingStarted.html#github",
    "href": "01_1_git-ingStarted.html#github",
    "title": "1¬† First steps with Git",
    "section": "2.6 GitHub",
    "text": "2.6 GitHub\nGitHub is a web service (among others, such as GitLab and Bitbucket) that can host Git repositories. GitHub is a natural place to store a remote repository. It allows you to control who can access or contribute to the repository, and is a great way to share (and find) open code.\nWe are going to use GitHub in this course in several exercises and the final project. You may wish to keep your final project from this semester in a public repository as a sort of portfolio project.\n\n\n\n\n\n\nGitHub Copilot and privacy\n\n\n\n\n\nBe aware that GitHub has an AI assistant, ‚ÄúCopilot‚Äù which is trained at least in part on code stored in GitHub. It is unclear which code is used for training, but most likely individual account repositories are used (both public and private).\n\n\n\nBefore moving forward, please create an account.\nAfter you‚Äôve created an account, you will need to set up SSH key authentication so that Git can access your remote repositories hosted at GitHub. GitHub no longer allows password authentication with command-line Git. You may have some experience with SSH keys already if you set them up for access to Xanadu. GitHub‚Äôs documentation for this is here.\nYou should set up ssh key access from both your local machine and Xanadu. If you have trouble with this, please reach out for help.\n\n2.6.1 Setting up GitHub as a remote repository\nThe easiest way to approach setting up GitHub as a remote with a new project is to start a new empty repository on GitHub (from your home page) and then clone it locally.\nIf you‚Äôve already got a repository started, you can more or less follow the same approach we did above. First go to your GitHub profile and click on the Repositories tab (e.g.¬†user isg-certificate would go to the page https://github.com/isg-certificate?tab=repositories) and click the green New button.\nEnter the name newproject, select ‚Äúpublic‚Äù or ‚Äúprivate‚Äù as you prefer and then click Create repository.\nGitHub will then tell you how to push an existing repository (although it will use main as the default main branch name, whereas in this material we have been using master).\nBefore you do this, however, let‚Äôs get rid of our extra clone and local remote:\n# force remove git repos\nrm -rf newproject_copy\nrm -rf newproject.git\n\n# remove current remote\ncd newproject\ngit remote remove origin\nNow we can add a new remote (again named origin). cd into newproject and:\ngit remote add origin git@github.com:isg-certificate/newproject.git\ngit branch -M master\ngit push -u origin master\nIf you go to the repository page on GitHub you should see your files hm.sh and hw.sh have been pushed there.\n\n\n2.6.2 README.md\nIt‚Äôs always advisable to include documentation. GitHub encourages this through the inclusion of a (GitHub flavored) markdown formatted document titled README.md. GitHub will format this document into HTML and include its contents on the splash page for the GitHub hosted repository.\nLet‚Äôs create a file locally in newproject now and push it to GitHub:\necho \"This is a dummy project to demo Git/GitHub\" &gt;README.md\ngit add README.md\ngit commit -m \"added README.md\"\ngit push\nNow visit the GitHub repository page and you should see the contents of README.md.",
    "crumbs": [
      "Introduction to Git",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>First steps with Git</span>"
    ]
  },
  {
    "objectID": "01_1_git-ingStarted.html#summing-up",
    "href": "01_1_git-ingStarted.html#summing-up",
    "title": "1¬† First steps with Git",
    "section": "2.7 Summing up",
    "text": "2.7 Summing up\nGit has many commands (type git to see them all). We have used the following:\n\ngit init to initialize a new repository.\ngit add to add a file to the staging area.\ngit commit to commit a staged snapshot of the working directory to the repository.\ngit status to summarize the current status of new, alterered, or staged files.\ngit remote to list and modify remote repositories.\ngit push to push changes to a remote repository.\ngit pull to pull changes from a remote repository. ## A few tips for thinking about Git/GitHub\nIn Bioinformatics, Git is used for code, documentation and sometimes figures or written reports. Don‚Äôt track analysis results unless they are very small and you think its important to version control them. fastqs, bams, etc should not be committed. Git is not meant for dealing with large data.\nGenerally think about Git as forward looking. If you want to delete a file, don‚Äôt think about deleting it from the history of the repository, think about deleting now and leaving it out in the future. If you want to restore a file (that was deleted or altered in a regrettable way) think about it as grabbing that file from a past commit and bringing it forward to replace your unwanted changes rather than ‚Äúundoing‚Äù them. We‚Äôll cover this in the next chapter.\nThere is a ton of stuff you can do with GitHub beyond hosting remote repositories (including hosting static web pages like this one!). We won‚Äôt get too far into it in this course.",
    "crumbs": [
      "Introduction to Git",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>First steps with Git</span>"
    ]
  },
  {
    "objectID": "01_2_moreGit.html",
    "href": "01_2_moreGit.html",
    "title": "2¬† More Git",
    "section": "",
    "text": "3 Learning Objectives\nIn the second chapter, we‚Äôre going to cover a few more topics.\nAgain, this will all be pretty short on explanation, make sure to refer to readings and videos in HuskyCT to understand better how things work.",
    "crumbs": [
      "Introduction to Git",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>More Git</span>"
    ]
  },
  {
    "objectID": "01_2_moreGit.html#restoring-past-versions",
    "href": "01_2_moreGit.html#restoring-past-versions",
    "title": "2¬† More Git",
    "section": "3.1 Restoring past versions",
    "text": "3.1 Restoring past versions\nConsider our newproject directory. It contains two files (and the hidden .git directory):\ntree\n.\n‚îú‚îÄ‚îÄ hm.sh\n‚îî‚îÄ‚îÄ hw.sh\n\n0 directories, 2 files\nThey should both be committed at this point.\nWhat happens if we make some modifications and we want to get rid of them? Like say, we overwrite the entire file.\necho 'oops!' &gt;hw.sh\ngit status will show us the file has been modified:\nOn branch master\nYour branch is up to date with 'origin/master'.\n\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n    modified:   hw.sh\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n3.1.1 When the changes are unstaged\nSo we‚Äôve made an edit, but haven‚Äôt staged it. We can grab the most recent committed version with:\ngit restore hw.sh\nNow cat hw.sh\n#!/bin/bash\n\necho \"Hello World!\"\nReveals the file has been restored.\n\n\n3.1.2 When the changes are staged\nIf we have already staged the file however, this won‚Äôt work directly, as it will simply check the file out from the staging area, not the most recent commit.\nIf you make the same mistake again, echo 'oops!' &gt;hw.sh, but this time stage the change git add hw.sh, you will see with git status:\nOn branch master\nYour branch is up to date with 'origin/master'.\n\nChanges to be committed:\n  (use \"git restore --staged &lt;file&gt;...\" to unstage)\n    modified:   hw.sh\nPer the message, you can unstage with\ngit restore --staged hw.sh\nAnd then go back to the last commit like before with git restore hw.sh.\n\n\n3.1.3 When the changes have been committed\nIf we make an edit and commit it:\necho 'echo \"Good day, world!\"' &gt;&gt;hw.sh\ngit add hw.sh\ngit commit -m \"good day\"\nWe‚Äôve now added a change to our repository. If we want to go back to a previous version (i.e without the ‚Äúgood day world‚Äù echo), we first need to identify the commit containing the file version we want. We can run git log to see a list of commits.\ncommit f8b8dcc6e75b325d4976f27d10c74f7154452d84 (HEAD -&gt; master)\nAuthor: Noah Reid &lt;noah@uconn.edu&gt;\nDate:   Fri Jan 10 11:23:27 1999 -0500\n\n    good day\n\ncommit ed8b357e46329f423101296fbba6b85b988972fc (origin/master)\nAuthor: Noah Reid &lt;noah@uconn.edu&gt;\nDate:   Fri Jan 10 10:44:00 1998 -0500\n\n    added hola mundo script\n\ncommit 39fb28833d64c1176fc4fa8dc010d0dbdf8ff374\nAuthor: Noah Reid &lt;noah@uconn.edu&gt;\nDate:   Fri Jan 10 10:43:07 1997 -0500\n\n    first commit\nCommits are uniquely identified by those long strings of letters and numbers. They are hashes of the snapshot (you can read more elsewhere!).\nTo get a version of the file from one of these commits:\ngit restore --source=ed8b357e hw.sh\nWe only need to provide enough of the hash that it is unique among commits. Now git status\nOn branch master\nYour branch is ahead of 'origin/master' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n    modified:   hw.sh\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nWe have restored our file, but not staged or committed it. We need to git add and then git commit. Now git log:\ncommit 3140e0d685f677c4ac2cc2123a8b53ef68eeee4a (HEAD -&gt; master)\nAuthor: Noah Reid &lt;noah.reid@uconn.edu&gt;\nDate:   Fri Jan 10 11:40:11 2025 -0500\n\n    restoring hw.sh\n\ncommit f8b8dcc6e75b325d4976f27d10c74f7154452d84\nAuthor: Noah Reid &lt;noah.reid@uconn.edu&gt;\nDate:   Fri Jan 10 11:23:27 2025 -0500\n\n    good day\n\ncommit ed8b357e46329f423101296fbba6b85b988972fc (origin/master)\nAuthor: Noah Reid &lt;noah.reid@uconn.edu&gt;\nDate:   Fri Jan 10 10:44:00 2025 -0500\n\n    added hola mundo script\n\ncommit 39fb28833d64c1176fc4fa8dc010d0dbdf8ff374\nAuthor: Noah Reid &lt;noah.reid@uconn.edu&gt;\nDate:   Fri Jan 10 10:43:07 2025 -0500\n\n    first commit\nWe can see we have added a new commit. We didn‚Äôt go backwards in our history so much as reached back to a previous file version and pulled it forward into a new change.\n\n\n3.1.4 Examining differences between file versions\nWhat if we‚Äôre not sure which commit to restore from? We can use git diff to examine differences between files:\nWe can compare file versions with git diff.\ngit diff f8b8dcc hw.sh\nThis tells git to compare the file hw.sh between the current working space and the commit hash beginning with f8b8dcc. The output:\ndiff --git a/hw.sh b/hw.sh\nindex 22b4300..cd16289 100644\n--- a/hw.sh\n+++ b/hw.sh\n@@ -1,4 +1,3 @@\n #!/bin/bash\n \n echo \"Hello World!\"\n-echo \"Good day, world!\"\nThere‚Äôs a lot here (nicely colored in the terminal), but you can see, essentially, that the line echo \"Good day, world!\" has been removed (signified by -) from our current version, relative to the commit we‚Äôre examining.\nIf you‚Äôre working on a local machine, you can use something else to view the diff results. For Visual Studio Code, you can configure the difftool command like this:\ngit config --global diff.tool vscode\ngit config --global difftool.vscode.cmd 'code --wait --diff $LOCAL $REMOTE'\nAs mentioned in the previous chapter, code will have to be in your PATH (linked instructions are there).\nNow\ngit difftool ed8b357e46329f4 hw.sh\nAnd after a prompt you should get a nicely formatted window with side-by-side files that makes it easy to see differences.",
    "crumbs": [
      "Introduction to Git",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>More Git</span>"
    ]
  },
  {
    "objectID": "01_2_moreGit.html#branching-and-merging",
    "href": "01_2_moreGit.html#branching-and-merging",
    "title": "2¬† More Git",
    "section": "3.2 Branching and merging",
    "text": "3.2 Branching and merging\nThis is one of the pillars of git and can get a little confusing, especially when remotes are brought into the equation.\nWhen working with an established code repository, you may have an idea you want to test out, but you are unsure of whether it will be any good, or it may take some time to implement and you don‚Äôt want to unsettle the existing code.\n\n3.2.1 Branching\nIn these cases you can create a new branch (again, see materials in huskyCT for more conceptual details). A branch is an independent line of commits. Repositories can have dozens of branches. Check the GitHub repository for the NF-Core pipeline rnaseq. Click the button with the branching icon that says master.\nAfter you have worked out your idea, if you decide it should become a part of the repository, you can merge it back into the main branch.\nWith our newproject repository, we can see existing branches like this:\ngit branch -vv\n* master 3140e0d [origin/master: ahead 2] restoring hw.sh\nThere‚Äôs only one branch currently. The * means this branch is currently what we see in the working directory. master is the name of the branch (the arbitrary default). 3140e0d is the beginning of the commit hash. [origin/master: ahead 2] indicates this branch is tracking a branch master at our remote origin and that it is two commits ahead of origin/master as of the last time we communicated with the remote. restoring hw.sh is the commit message from the last commit.\nLet‚Äôs make a new branch.\ngit branch goodbye\nNow git branch -vv\n  goodbye 3140e0d restoring hw.sh\n* master  3140e0d [origin/master: ahead 2] restoring hw.sh\nWe have a new branch goodbye. We didn‚Äôt switch to that branch, however (* is still on master), and importantly this branch is not on our remote (or any remote).\nTo switch to the branch:\ngit checkout goodbye\nNow git branch -vv\n* goodbye 3140e0d restoring hw.sh\n  master  3140e0d [origin/master: ahead 2] restoring hw.sh\nLet‚Äôs add some new files:\ncat &lt;&lt;EOF &gt;gw.sh\n#!/bin/bash\n\necho \"Goodbye World!\"\nEOF\n\ncat &lt;&lt;EOF &gt;am.sh\n#!/bin/bash\n\necho \"Adios Mundo!\"\nEOF\nAdd git add --all and commit git commit -m \"goodbye\"\nNow we‚Äôve added two brand new files that should only be present on branch goodbye.\nSee ls\nam.sh  gw.sh  hm.sh  hw.sh\nNow switch branches git checkout master and ls\nhm.sh  hw.sh\nNow back to goodbye with git checkout goodbye.\nLet‚Äôs look at our history another way git log --decorate. The --decorate option will write the names of any references. References very simply point at commits. While conceptually a branch is much like the branch of a tree, when you create a branch, git creates one of these pointers with the name of your branch and attaches it to a commit. The last few commits with references added:\ngit log --decorate\ncommit 45f76a809cc3b03c53d7fe1e91ab23944438f5a2 (HEAD, goodbye)\nAuthor: Noah Reid &lt;noah.reid@uconn.edu&gt;\nDate:   Fri Jan 10 14:44:40 2001 -0500\n\n    goodbye\n\ncommit 3140e0d685f677c4ac2cc2123a8b53ef68eeee4a (master)\nAuthor: Noah Reid &lt;noah.reid@uconn.edu&gt;\nDate:   Fri Jan 10 11:40:11 2000 -0500\n\n    restoring hw.sh\n\ncommit f8b8dcc6e75b325d4976f27d10c74f7154452d84\nAuthor: Noah Reid &lt;noah.reid@uconn.edu&gt;\nDate:   Fri Jan 10 11:23:27 1999 -0500\n\n    good day\n\ncommit ed8b357e46329f423101296fbba6b85b988972fc (origin/master)\nAuthor: Noah Reid &lt;noah.reid@uconn.edu&gt;\nDate:   Fri Jan 10 10:44:00 1998 -0500\n\n    added hola mundo script\nWe have references HEAD, goodbye, master and origin/master.\nHEAD is a special pointer telling us which commit is currently checked out in our working directory (uncommitted changes notwithstanding). goodbye is the reference for our current branch. origin/master is a remote tracking branch (more shortly) telling us which commit the remote was one when we last checked in with it.\nWe can put HEAD on a commit without a branch, but this isn‚Äôt a great state of affairs:\ngit checkout f8b8dcc6e75b325d4976f27d10c74f7154452d84\nNote: checking out 'f8b8dcc6e75b325d4976f27d10c74f7154452d84'.\n\nYou are in 'detached HEAD' state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by performing another checkout.\n\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -b with the checkout command again. Example:\n\n  git checkout -b new_branch_name\n\nHEAD is now at f8b8dcc... good day\ndetached HEAD state means the HEAD pointer is on a commit but has no branch. As the message says, you can create a new branch from this point, or just git checkout goodbye to get back to your original commit.\nSee git log --decorate to validate that HEAD is all by its lonesome.\nmaster is currently directly upstream of goodbye, but branches can diverge down independent paths. Lets make a couple changes to master. First git checkout master.\necho 'echo Hiya World!' &gt;&gt;hw.sh\n\ncat &lt;&lt;EOF &gt;bl.sh\n#!/bin/bash\n\necho 'Bonjour le Monde!'\nEOF\nWe‚Äôve added a file and altered one. Now git add --all and git commit -m \"more hi\"\nIf you do git log --decorate now, you‚Äôll see the pointer for goodbye has disappeared. It‚Äôs not gone, but it‚Äôs not part of the commit history for master at this point. The changes we made to goodbye and master are on diverging branches.\n\n\n3.2.2 Merging\nNow at this point we may be happy with changes we‚Äôve made to both branches and want to incorporate them. For this we use git merge. If we assume master is going to be our main branch, we probably want to incorporate our changes there.\nSo git checkout master to ensure we‚Äôre there, and git merge goodbye. This should drop you into whatever text editor you‚Äôve specified (if it‚Äôs vim, see last chapter) to write a message about the merge.\nGit is smart enough that it can figure out our changes don‚Äôt conflict with each other at the level of text, so it brings them all together. This doesn‚Äôt rule out a merge breaking functionality at some higher level.\nWhen changes cannot be trivially merged, git will ask you to edit the conflicting files.\nIf you‚Äôve merged a branch and you‚Äôre done with it, you can delete it (not the commit history, just the pointer).\ngit branch -d goodbye",
    "crumbs": [
      "Introduction to Git",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>More Git</span>"
    ]
  },
  {
    "objectID": "01_2_moreGit.html#branching-and-remotes",
    "href": "01_2_moreGit.html#branching-and-remotes",
    "title": "2¬† More Git",
    "section": "3.3 Branching and Remotes",
    "text": "3.3 Branching and Remotes\nWith remotes, things get a little more complicated. In the above example, we created a branch goodbye, made edits and then deleted the branch pointer without ever pushing the changes to the remote repository. goodbye never existed on the remote. If we push the changes now, the commit history will be recorded on the remote, but there hasn‚Äôt been and will not be a goodbye branch there.\nIf we want a branch to be represented on the remote (because we want collaborators to see it or work on it or we want to back it up), we need to add it there. When we do that, two things happen.\n\nWe create the branch on the remote (and push our commit history there).\nWe create another branch locally, called a remote tracking branch.\n\nLet‚Äôs see how this goes.\nCreate a new branch and check it out.\ngit branch congratulations\ngit checkout congratulations\nMake an edit.\ncat &lt;&lt;EOF &gt;cw.sh\n#!/bin/bash\n\necho 'Congratulations World!'\nEOF\nNow git add and git commit. If we simply try to push the branch, git will push our changes on master, but not those on congratulations. Try it and check out your remote (on GitHub, ideally, at this point).\ngit push\nTo create the branch on the remote and the remote tracking branch locally:\ngit push -u origin congratulations\nWith output:\nCounting objects: 4, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (2/2), done.\nWriting objects: 100% (3/3), 306 bytes | 0 bytes/s, done.\nTotal 3 (delta 1), reused 0 (delta 0)\nremote: Resolving deltas: 100% (1/1), completed with 1 local object.\nremote: \nremote: Create a pull request for 'congratulations' on GitHub by visiting:\nremote:      https://github.com/isg-certificate/newproject/pull/new/congratulations\nremote: \nTo git@github.com:isg-certificate/newproject.git\n * [new branch]      congratulations -&gt; congratulations\nBranch congratulations set up to track remote branch congratulations from origin.\nThe remote tracking branch keeps track of where in our commit history the remote was the last time we communicated with the remote. Above in the git log --decorate output we saw the branch (or reference, or pointer) origin/master indicating the commit associated with the remote tracking branch. We can see remote tracking branches with the -a flag in git branch\ngit branch -a -vv\n* congratulations                c6f675f [origin/congratulations] congratulations\n  master                         1c735ce [origin/master] Merge branch 'goodbye'\n  remotes/origin/congratulations c6f675f congratulations\n  remotes/origin/master          1c735ce Merge branch 'goodbye'\nNow that we‚Äôre tracking a branch that exists on our remote origin, it‚Äôs possible for the remote tracking branch and our local congratulations branch to diverge just like master and goodbye did above.\nThis can happen if work happens on the branches in two different places without pushing and pulling changes to and from the remote (such as when you work at two workstations, or a collaborator contributes). If the remote branch gets ahead of your tracking branch, git will not allow you to push new changes from your version of the branch before you get the changes from the remote and merge them.\nYou can update the tracking branch with git fetch and then you can do git merge to merge the tracking and local branches (fixing any conflicts as necessary) or you can do git pull, which updates the remote tracking branch and merges in one command (which will still require you to fix conflicts).",
    "crumbs": [
      "Introduction to Git",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>More Git</span>"
    ]
  },
  {
    "objectID": "01_2_moreGit.html#forking-and-pull-requests-on-github",
    "href": "01_2_moreGit.html#forking-and-pull-requests-on-github",
    "title": "2¬† More Git",
    "section": "3.4 Forking and pull requests on GitHub",
    "text": "3.4 Forking and pull requests on GitHub\nWe aren‚Äôt going to demo forking and pull requests here, because the key parts of that occur on the GitHub web site. But to put this in context: a single git repository can have branches that diverge and then merge again. When working with remotes, the complexity increases, especially when you have collaborators. Branches can exist in local repositories, but not the remote, and then be added to the remote (creating remote tracking branches in the local repository), and all these different branches can diverge and then be merged in various sequences.\nForking adds another layer of complexity. On GitHub you can fork someone else‚Äôs public repository. This is a bit like cloning it, except you are creating a mostly independent copy of it under your own account. You might create forks for a couple reasons:\n\nYou want to mess around with the repository and possibly adapt it to your own needs.\nYou found something you don‚Äôt like about the repository and you want to improve it, potentially sending your improvements back to the original developers for incorporation.\n\nIn both these cases, you probably don‚Äôt have permission to modify the original repository, or maybe your modifications would not be appropriate to its original purpose. You are likely not a close collaborator or co-worker if you are forking a repository, otherwise you would probably be able to simply clone the original and create branches to incorporate your work.\nOn your fork, you can do whatever you want. It‚Äôs your copy. You can‚Äôt accidentally push bad changes to the origina.\nIf you want to alter the original, however, you can create a pull request. This is a GitHub feature that allows you to notify the repository‚Äôs owner that you‚Äôve made a change you think should be incorporated into the original. The pull request creates a discussion thread that allows the owner to see what you‚Äôve proposed and talk about the changes, possibly asking you to tweak them.\nIn the end, the owner can merge the changes proposed from your fork in the original repository. Instead of doing this here, we‚Äôll have an assignment where students fork each other‚Äôs repositories and make pull requests.",
    "crumbs": [
      "Introduction to Git",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>More Git</span>"
    ]
  },
  {
    "objectID": "01_2_moreGit.html#assorted-git-topics",
    "href": "01_2_moreGit.html#assorted-git-topics",
    "title": "2¬† More Git",
    "section": "3.5 Assorted Git Topics",
    "text": "3.5 Assorted Git Topics",
    "crumbs": [
      "Introduction to Git",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>More Git</span>"
    ]
  },
  {
    "objectID": "01_2_moreGit.html#visualizing-the-commit-history",
    "href": "01_2_moreGit.html#visualizing-the-commit-history",
    "title": "2¬† More Git",
    "section": "3.6 Visualizing the commit history",
    "text": "3.6 Visualizing the commit history\nThis has all been fairly abstract. If you think it might be helpful to be able to quickly visualize the history of a repository and the changes made to files, check out Sourcetree. You don‚Äôt have to connect it to your GitHub account, but you can if you want. To have a look at how it works, try cloning NF-Core‚Äôs rnaseq repository. This is a big repository with a lot of collaborators. If you want, you can make some arbitrary commits, branches, etc and see how they show up in the visualization of the history. Even though the GitHub repository is still the remote, you won‚Äôt have permission to push any changes.\n\n3.6.1 Ignoring files\nYou may want to git add --all sometimes when you have many changes to incorporate into a repository. However, it‚Äôs often the case in data analysis that as you develop your set of scripts and run them that you generate files you don‚Äôt want to commit, such as results and log files. You may also want to organize your project so that your data (or a symlink to your data) are inside the project directory to keep everything self-contained, and large raw data sets definitely don‚Äôt belong in a git repository.\nFor cases like these, you can create a file in the root of your working directory, .gitignore and write out file names and patterns there that you want git to ignore.\nCheck out the .gitignore file for this repository containing scripts for a bulk RNA-seq/differential expression tutorial.\nIt‚Äôs got a lot in it because these scripts all write results together, but briefly:\n-**/results matches any directory or file named results anywhere (and thus also ignores the contents of the directory) -*.fa matches any file ending in .fa\nThe documentation contains more details on pattern matching in .gitignore.\nYou can commit the .gitignore file to keep it as part of the repository.\n\n\n3.6.2 Removing and renaming\nYou can rm and mv just like you normally do, but it makes more work with Git. If you remove with git rm and rename (or move) with git mv Git will handle it better and stage the changes for you.\n\n\n3.6.3 Git is kind of hard\nWhile the basic ideas behind the Git workflow are not that challenging, when getting more involved in collaborations, working with remotes, and actually navigating the complexity of the command-line tools, things can get difficult. Depending on how and how much you use git, you should expect there to be a somewhat long learning curve. Don‚Äôt get discouraged, it‚Äôs a useful and widespread tool and great to have some experience with.",
    "crumbs": [
      "Introduction to Git",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>More Git</span>"
    ]
  },
  {
    "objectID": "01_0_IntroToGit.html",
    "href": "01_0_IntroToGit.html",
    "title": "Introduction to Git",
    "section": "",
    "text": "Learning Objectives\n\n\n\n\n\n\nLearning Objectives:\n\n\nCreate a code repository with git.\n\n\nSet up a documented remote copy of the repository on github.\n\n\nBranch the repository to edit, and then merge changes.\n\n\nWork collaboratively.\n\n\n\nIn this module we will learn the basics of the version control software git, and how to set up a remote code repository on the web service GitHub.\nThese chapters will be somewhat sparse, as you will be referred to existing training material in HuskyCT.\nMany (perhaps most?) people find Git to be a bit confusing at times. You should prepare for that possibility, and know that you may need to refer to documentation or seek help.",
    "crumbs": [
      "Introduction to Git"
    ]
  },
  {
    "objectID": "02_0_variantDetection.html",
    "href": "02_0_variantDetection.html",
    "title": "Variant Detection and Genotyping",
    "section": "",
    "text": "Learning Objectives\n\n\n\n\n\n\nLearning Objectives:\n\n\nFIRST OBJECTIVE",
    "crumbs": [
      "Variant Detection and Genotyping"
    ]
  },
  {
    "objectID": "03_0_genomeAssembly.html",
    "href": "03_0_genomeAssembly.html",
    "title": "Genome Assembly",
    "section": "",
    "text": "Learning Objectives\n\n\n\n\n\n\nLearning Objectives:\n\n\nFIRST OBJECTIVE",
    "crumbs": [
      "Genome Assembly"
    ]
  },
  {
    "objectID": "04_0_scRNAseq.html",
    "href": "04_0_scRNAseq.html",
    "title": "Single-cell RNAseq",
    "section": "",
    "text": "Learning Objectives\n\n\n\n\n\n\nLearning Objectives:\n\n\nFIRST OBJECTIVE",
    "crumbs": [
      "Single-cell RNAseq"
    ]
  },
  {
    "objectID": "05_0_workflows.html",
    "href": "05_0_workflows.html",
    "title": "Pipeline development with Nextflow",
    "section": "",
    "text": "Learning Objectives\n\n\n\n\n\n\nLearning Objectives:\n\n\nFIRST OBJECTIVE",
    "crumbs": [
      "Pipeline development with Nextflow"
    ]
  }
]